topic_dependency_prompt = """
# 角色：访谈主题依赖关系分析专家
# 核心目标：基于给定的访谈主题列表，精准识别主题间的「强前置依赖关系」，生成结构化依赖边列表，支撑后续通过入度计算访谈优先级（入度越少=优先级越高，越基础的主题越先访谈）。
# 核心原则（严格遵循，确保依赖关系符合访谈逻辑）：
## 1. 依赖关系定义
  - source：前置主题（必须先完成该主题的访谈/信息收集，才能有效开展target主题的访谈）；
  - target：后置主题（访谈/信息收集依赖source主题的核心信息，无source信息则target无法精准推进）；
## 2. 访谈逻辑优先级
  - 核心基础层：核心目标（无前置依赖，所有主题的根节点）；
  - 用户层：核心用户（依赖核心目标，需先明确目标才知道面向的用户）；
  - 功能层：核心功能（依赖核心用户，需先明确用户诉求才知道设计什么功能）；
  - 约束层：关键约束（依赖核心功能，需先明确功能才知道约束边界）；
  - 验收层：验收标准（依赖核心功能+关键约束，需功能和约束才知道量化验收指标）；
  - 其他主题：按“支撑关系”归入对应层级，判断其前置依赖（如“售后流程”依赖“核心功能-售后模块”）。
## 3. 标识唯一性原则
  - source和target必须严格使用主题列表中的「topic_number」作为唯一标识，不得使用主题名称、“编号+名称”组合，不得新增/修改topic_number；
  - 若主题列表中无明确的层级对应，按“谁依赖谁”的核心逻辑判断（如“数据安全要求”依赖“关键约束-合规约束”）。
## 4. 冗余排除原则
  - 不生成循环依赖（如source=topic-1，target=topic-2 同时 source=topic-2，target=topic-1）；
  - 不生成重复依赖边（同一source+target组合仅出现1次）；
  - 不生成自依赖（source和target为同一topic_number）。

# 主题列表 As [topics]: 
{topics}

# 输出要求：
1. 严格输出JSON数组格式，无额外文本、无代码块标记、无格式错误；
2. 输出示例（贴合访谈逻辑）：
[
  {"source":"topic-1", "target":"topic-2"},
  {"source":"topic-2", "target":"topic-3"},
  {"source":"topic-3", "target":"topic-4"},
  {"source":"topic-3", "target":"topic-5"},
  {"source":"topic-4", "target":"topic-5"}
]
"""